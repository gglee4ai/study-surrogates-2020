---
title: "R Notebook"
output: html_notebook
---



```{r}
yield <- function(xi1, xi2) {
  xi1 <- 3*xi1 - 15
  xi2 <- xi2/50 - 13
  xi1 <- cos(0.5)*xi1 - sin(0.5)*xi2
  xi2 <- sin(0.5)*xi1 + cos(0.5)*xi2
  y <- exp(-xi1^2/80 - 0.5*(xi2 + 0.03*xi1^2 - 40 *0.03)^2)
  return(100*y)
}
```

```{r}
xi1 <- seq(1, 8, length=100)
xi2 <- seq(100, 1000, length=100)
g <- expand.grid(xi1, xi2)
y <- yield(g[, 1], g[, 2])
```

```{r}
persp(xi1, xi2, matrix(y, ncol=length(xi2)), 
      theta=45, phi=45, lwd=0.5, 
      xlab="xi1 : time", ylab="xi2 : temperature", zlab="yield", 
      expand=0.4)
```

```{r}
cols <- heat.colors(128)
image(xi1, xi2, matrix(y, ncol=length(xi2)), col=cols,
      xlab="xi1 : time", ylab="xi2 : temperature")
contour(xi1, xi2, matrix(y, ncol=length(xi2)), nlevels=4, add=TRUE)
```

```{r}
first.order <- function(x1, x2) {
  50 + 8*x1 + 3*x2
}
```

```{r}
x1 <- x2 <- seq(-1, 1, length=100)
g=expand.grid(x1, x2)
eta1 <- matrix(first.order(g[, 1], g[, 2]), ncol=length(x2))
```

```{r}
par(mfrow=c(1, 2))
persp(x1, x2, eta1, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta1, col=heat.colors(128))
contour(x1, x2, matrix(eta1, ncol=length(x2)), add=TRUE)
```

```{r}
first.order.i <- function(x1, x2) {
  50 + 8*x1 + 3*x2 - 4*x1*x2
}
```

```{r}
eta1i <- matrix(first.order.i(g[, 1], g[, 2]), ncol=length(x2))
```

```{r}
par(mfrow=c(1, 2))
persp(x1, x2, eta1i, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta1i)
contour(x1, x2, eta1i, add=TRUE)
```

```{r}
simple.max <- function(x1, x2) {
  50 + 8*x1 + 3*x2 - 7*x1^2 - 3*x2^2 - 4*x1*x2
}
```

```{r}
eta2sm <- matrix(simple.max(g[,1], g[,2]), ncol=length(x2))
```

```{r}
par(mfrow=c(1,2))
persp(x1, x2, eta2sm, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2sm, col=heat.colors(128))
contour(x1, x2, eta2sm, add=TRUE)
```

```{r}
stat.ridge <- function(x1, x2) {
  80 + 4*x1 + 8*x2 - 3*x1^2 - 12*x2^2 - 12*x1*x2
}
```

```{r}
eta2sr <- matrix(stat.ridge(g[,1], g[,2]), ncol=length(x2))
```

```{r}
par(mfrow=c(1,2))
persp(x1, x2, eta2sr, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2sr, col=heat.colors(128))
contour(x1, x2, eta2sr, add=TRUE)
```
```{r}
rise.ridge <- function(x1, x2) {
  80 - 4*x1 + 12*x2 - 3*x1^2 - 12*x2^2 - 12*x1*x2
}
```

```{r}
eta2rr <- matrix(rise.ridge(g[,1], g[,2]), ncol=length(x2))
```

```{r}
par(mfrow=c(1,2))
persp(x1, x2, eta2rr, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2rr, col=heat.colors(128))
contour(x1, x2, eta2rr, add=TRUE)
```


```{r}
saddle <- function(x1, x2) {
  80 + 4*x1 + 8*x2 - 2*x1 - 12*x2 - 12*x1*x2 
}
```

```{r}
eta2s <- matrix(saddle(g[,1], g[,2]), ncol=length(x2))
```

```{r}
par(mfrow=c(1, 2))
persp(x1, x2, eta2s, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2s, col=heat.colors(128))
contour(x1, x2, eta2s, add=TRUE)
```

```{r}
wingwt <- function(Sw=0.48, Wfw=0.4, A=0.38, L=0.5, q=0.62, l=0.344, 
  Rtc=0.4, Nz=0.37, Wdg=0.38) {
  ## put coded inputs back on natural scale
  Sw <- Sw*(200 - 150) + 150 
  Wfw <- Wfw*(300 - 220) + 220 
  A <- A*(10 - 6) + 6 
  L <- (L*(10 - (-10)) - 10) * pi/180
  q <- q*(45 - 16) + 16 
  l <- l*(1 - 0.5) + 0.5 
  Rtc <- Rtc*(0.18 - 0.08) + 0.08
  Nz <- Nz*(6 - 2.5) + 2.5
  Wdg <- Wdg*(2500 - 1700) + 1700

  ## calculation on natural scale
  W <- 0.036*Sw^0.758 * Wfw^0.0035 * (A/cos(L)^2)^0.6 * q^0.006 
  W <- W * l^0.04 * (100*Rtc/cos(L))^(-0.3) * (Nz*Wdg)^(0.49)
  return(W)
}
```


```{r}
x <- seq(0, 1, length=100)
g <- expand.grid(x, x)
W.A.Nz <- wingwt(A=g[, 1], Nz=g[, 2])
```

```{r}
cs <- heat.colors(128)
bs <- seq(min(W.A.Nz), max(W.A.Nz), length=129)
```

```{r, fig.asp=1, fig.width=3}
image(x, x, matrix(W.A.Nz, ncol = length(x)), col=cs, breaks=bs, xlab="A", ylab="Nz")
contour(x, x, matrix(W.A.Nz, ncol=length(x)), add=TRUE)
```

```{r}
W.l.Wfw <- wingwt(l=g[,1], Wfw=g[,2])
```

```{r}
par(pty="s")
image(x, x, matrix(W.l.Wfw,ncol=length(x)), col=cs, breaks=bs, 
  xlab="l", ylab="Wfw")
contour(x,x, matrix(W.l.Wfw,ncol=length(x)), add=TRUE)
```

```{r}
library(lhs)
n <- 1000
X <- data.frame(randomLHS(n, 9))
names(X) <- names(formals(wingwt))
X
```

```{r}
par(pty="s")
plot(X[, 1:2], pch=19, cex=0.5)
abline(h=c(0.6, 0.8), col=2, lwd=2)
```

```{r}
inbox <- X[,1] > 0.6 & X[,1] < 0.8
sum(inbox)/nrow(X)
```

```{r}
Y <- wingwt(X[,1], X[,2], X[,3], X[,4], X[,5], X[,6], X[,7], X[,8], X[,9])
Y
```

```{r}
fit.lm <- lm(log(Y) ~ .^2, data=data.frame(Y,X))
fit.lmstep <- step(fit.lm, scope=formula(fit.lm), direction="backward", 
  k=log(length(Y)), trace=0)
```


```{r}
coef(fit.lmstep)
```

```{r}
#install.packages("laGP")
library(laGP)
```

```{r}
fit.gp <- newGPsep(X, Y, 2, 1e-6, dK=TRUE)
mle <- mleGPsep(fit.gp)
```
































