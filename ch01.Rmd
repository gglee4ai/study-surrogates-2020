---
title: "Chapter 1"
output: html_notebook
---


```{r}
yield <- function(xi1, xi2) {
  xi1 <- 3*xi1 - 15
  xi2 <- xi2/50 - 13
  xi1 <- cos(0.5)*xi1 - sin(0.5)*xi2
  xi2 <- sin(0.5)*xi1 + cos(0.5)*xi2
  y <- exp(-xi1^2/80 - 0.5*(xi2 + 0.03*xi1^2 - 40 *0.03)^2)
  return(100*y)
}
```


```{r}
xi1 <- seq(1, 8, length=100)
xi2 <- seq(100, 1000, length=100)
g <- expand.grid(xi1, xi2)
y <- yield(g[,1], g[,2])
```


```{r}
par(pty="s")
persp(xi1, xi2, matrix(y, ncol=length(xi2)), 
      theta=45, phi=45, lwd=0.5, 
      xlab="xi1 : time", ylab="xi2 : temperature", zlab="yield", 
      expand=0.4)
```


```{r}
par(pty="s")
cols <- heat.colors(128)
image(xi1, xi2, matrix(y, ncol=length(xi2)), col=cols,
      xlab="xi1 : time", ylab="xi2 : temperature")
contour(xi1, xi2, matrix(y, ncol=length(xi2)), nlevels=4, add=TRUE)
```


```{r}
first.order <- function(x1, x2) {
  50 + 8*x1 + 3*x2
}
```


```{r}
x1 <- x2 <- seq(-1, 1, length=100)
g <- expand.grid(x1, x2)
eta1 <- matrix(first.order(g[,1], g[,2]), ncol=length(x2))
```


```{r}
par(mfrow=c(1, 2), pty="s")
persp(x1, x2, eta1, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta1, col=heat.colors(128))
contour(x1, x2, matrix(eta1, ncol=length(x2)), add=TRUE)
```


```{r}
first.order.i <- function(x1, x2) {
  50 + 8*x1 + 3*x2 - 4*x1*x2
}
```


```{r}
eta1i <- matrix(first.order.i(g[,1], g[,2]), ncol=length(x2))
```


```{r}
par(mfrow=c(1, 2), pty="s")
persp(x1, x2, eta1i, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta1i, col=heat.colors(128))
contour(x1, x2, eta1i, add=TRUE)
```

```{r}
simple.max <- function(x1, x2) {
  50 + 8*x1 + 3*x2 - 7*x1^2 - 3*x2^2 - 4*x1*x2
}
```


```{r}
eta2sm <- matrix(simple.max(g[,1], g[,2]), ncol=length(x2))
```


```{r}
par(mfrow=c(1,2), pty="s")
persp(x1, x2, eta2sm, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2sm, col=heat.colors(128))
contour(x1, x2, eta2sm, add=TRUE)
```


```{r}
stat.ridge <- function(x1, x2) {
  80 + 4*x1 + 8*x2 - 3*x1^2 - 12*x2^2 - 12*x1*x2
}
```


```{r}
eta2sr <- matrix(stat.ridge(g[,1], g[,2]), ncol=length(x2))
```


```{r}
par(mfrow=c(1,2), pty="s")
persp(x1, x2, eta2sr, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2sr, col=heat.colors(128))
contour(x1, x2, eta2sr, add=TRUE)
```


```{r}
rise.ridge <- function(x1, x2) {
  80 - 4*x1 + 12*x2 - 3*x1^2 - 12*x2^2 - 12*x1*x2
}
```


```{r}
eta2rr <- matrix(rise.ridge(g[,1], g[,2]), ncol=length(x2))
```


```{r}
par(mfrow=c(1,2), pty="s")
persp(x1, x2, eta2rr, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2rr, col=heat.colors(128))
contour(x1, x2, eta2rr, add=TRUE)
```


```{r}
saddle <- function(x1, x2) {
  80 + 4*x1 + 8*x2 - 2*x1 - 12*x2 - 12*x1*x2 
}
```


```{r}
eta2s <- matrix(saddle(g[,1], g[,2]), ncol=length(x2))
```


```{r}
par(mfrow=c(1, 2), pty="s")
persp(x1, x2, eta2s, theta=30, phi=30, zlab="eta", expand=0.75, lwd=0.25)
image(x1, x2, eta2s, col=heat.colors(128))
contour(x1, x2, eta2s, add=TRUE)
```


```{r}
wingwt <- function(Sw=0.48, Wfw=0.4, A=0.38, L=0.5, q=0.62, l=0.344, 
  Rtc=0.4, Nz=0.37, Wdg=0.38) {
  ## put coded inputs back on natural scale
  Sw <- Sw*(200 - 150) + 150 
  Wfw <- Wfw*(300 - 220) + 220 
  A <- A*(10 - 6) + 6 
  L <- (L*(10 - (-10)) - 10) * pi/180
  q <- q*(45 - 16) + 16 
  l <- l*(1 - 0.5) + 0.5 
  Rtc <- Rtc*(0.18 - 0.08) + 0.08
  Nz <- Nz*(6 - 2.5) + 2.5
  Wdg <- Wdg*(2500 - 1700) + 1700

  ## calculation on natural scale
  W <- 0.036*Sw^0.758 * Wfw^0.0035 * (A/cos(L)^2)^0.6 * q^0.006 
  W <- W * l^0.04 * (100*Rtc/cos(L))^(-0.3) * (Nz*Wdg)^(0.49)
  return(W)
}
```


```{r}
x <- seq(0, 1, length=100)
g <- expand.grid(x, x)
W.A.Nz <- wingwt(A=g[,1], Nz=g[,2])
```


```{r}
cs <- heat.colors(128)
bs <- seq(min(W.A.Nz), max(W.A.Nz), length=129)
```


```{r}
par(pty="s")
image(x, x, matrix(W.A.Nz, ncol = length(x)), col=cs, breaks=bs, xlab="A", ylab="Nz")
contour(x, x, matrix(W.A.Nz, ncol=length(x)), add=TRUE)
```


```{r}
W.l.Wfw <- wingwt(l=g[,1], Wfw=g[,2])
```


```{r}
par(pty="s")
image(x, x, matrix(W.l.Wfw,ncol=length(x)), col=cs, breaks=bs, 
  xlab="l", ylab="Wfw")
contour(x,x, matrix(W.l.Wfw,ncol=length(x)), add=TRUE)
```


```{r}
library(lhs)
n <- 1000
X <- data.frame(randomLHS(n, 9))
names(X) <- names(formals(wingwt))
X
```


```{r}
par(pty="s")
plot(X[,1:2], pch=19, cex=0.5)
abline(h=c(0.6, 0.8), col=2, lwd=2)
```


```{r}
inbox <- X[,1] > 0.6 & X[,1] < 0.8
sum(inbox)/nrow(X)
```


```{r}
Y <- wingwt(X[,1], X[,2], X[,3], X[,4], X[,5], X[,6], X[,7], X[,8], X[,9])
Y
```


```{r}
fit.lm <- lm(log(Y) ~ .^2, data=data.frame(Y,X))
fit.lmstep <- step(fit.lm, scope=formula(fit.lm), direction="backward", 
  k=log(length(Y)), trace=0) # BIC 이용
  # k=2, trace=0) # AIC 이용 
```


```{r}
coef(fit.lmstep)
```


```{r}
#install.packages("laGP")
library(laGP)
```


```{r}
fit.gp <- newGPsep(X, Y, 2, 1e-6, dK=TRUE)
mle <- mleGPsep(fit.gp)
```


```{r}
baseline <- matrix(rep(as.numeric(formals(wingwt)), nrow(g)), ncol=9, byrow=TRUE)
XX <- data.frame(baseline)
names(XX) <- names(X)
XX$A <- g[,1]
XX$Nz <- g[,2]
```


```{r}
p <- predGPsep(fit.gp, XX, lite=TRUE)
p
```


```{r}
par(pty="s")
image(x, x, matrix(p$mean, ncol=length(x)), col=cs, breaks=bs, xlab="A", ylab="Nz")
contour(x, x, matrix(p$mean, ncol=length(x)), add=TRUE)
```


```{r}
meq1 <- meq2 <- me <- matrix(NA, nrow=length(x), ncol=ncol(X))
for (i in 1:ncol(me)) {
  XX <- data.frame(baseline)[1:length(x),]
  XX[,i] <- x
  p <- predGPsep(fit.gp, XX, lite=TRUE)
  me[,i] <- p$mean
  meq1[,i] <- qt(0.05, p$df)*sqrt(p$s2) + p$mean
  meq2[,i] <- qt(0.95, p$df)*sqrt(p$s2) + p$mean
}
```


```{r}
par(pty="s")
matplot(x, me, type="l", lwd=2, lty=1, col=1:9, xlab="coded input")
matlines(x, meq1, type="l", lwd=2, lty=2, col=1:9)
matlines(x, meq2, type="l", lwd=2, lty=2, col=1:9)
legend("topleft", names(X)[1:5], lty=1, col=1:5, horiz=TRUE, bty="n", cex=0.5)
legend("bottomright", names(X)[6:9], lty=1, col=6:9, horiz=TRUE, bty="n", cex=0.5)
```


# Homework exercises

## Regression

```{r}
wire <- read.csv("dataset/wire.csv")
wire
```


```{r}
wire_min <- unlist(lapply(wire, min))
wire_med <- unlist(lapply(wire, median))
wire_max <- unlist(lapply(wire, max))
wire_table <- as.data.frame(t(rbind(wire_min, wire_med, wire_max)))
colnames(wire_table) <- c("med", "min", "max")
wire_table
```


```{r}
scaler_minmax <- function(x) {
  (x - min(x)) / (max(x) - min(x))
}

X <- as.data.frame(apply(wire[,2:7], 2, scaler_minmax))
X
```


```{r}
Y <- wire[,1]
Y
```


```{r}
fit_lm1 <- lm(Y ~ ., data = data.frame(Y, X))
fit_lm1
```


```{r}
fit_lm2 <- lm(Y ~ .^2, data = data.frame(Y, X))
fit_lm2
```


```{r}
fit_lm1_step <- step(fit_lm1, scope=formula(fit_lm1), direction="backward", 
  k=2, trace=0)
fit_lm1_step
```


```{r}
fit_gp <- newGPsep(X, Y, 2, 1e-6, dK=TRUE)
mle <- mleGPsep(fit_gp)
```


```{r}
x <- seq(0, 1, length=101)
g <- expand.grid(x, x)

b <- unlist(lapply(X, median))

baseline <- matrix(rep(b, nrow(g)), ncol=ncol(X), byrow=TRUE)
head(baseline)
nrow(baseline)
```


```{r}
XX <- data.frame(baseline)
names(XX) <- names(X)
XX$dieh <- g[, 1]
XX$posth <- g[, 2]
XX
```


```{r}
p <- predGPsep(fit_gp, XX, lite=TRUE)
```


```{r}
par(pty="s")
cs <- heat.colors(128)
#bs <- seq(, 20, length=129)
image(x, x, matrix(p$mean, ncol=length(x)), col=cs, #breaks=bs, 
  xlab="dieh", ylab="psth")
contour(x, x, matrix(p$mean, ncol=length(x)), add=TRUE)
```















